# Выполнение HTTP-запросов с помощью сокетов в Python #

### Практическое введение в сетевое программирование, от конфигурации сокетов до сетевых буферов и режимов соединения HTTP. ###

#### ДРУГИЕ СТАТЬИ ИЗ ЭТОЙ СЕРИИ ####
Введение в компьютерные сети — Взгляд с высоты птичьего полета на искусство совместного использования ресурсов с одного компьютера на другой.

Понимание Интернета — *«Эта штука все еще существует?»* - Гомер Симпсон

Введение в протокол TCP/IP — официальные правила, позволяющие компьютерам обмениваться данными через Интернет.

Введение в IP: Интернет-протокол — от маршрутизации до IP-адресации, взгляд на протокол, который дает жизнь Интернету.

Введение в TCP: протокол управления передачей — один из наиболее важных протоколов высокого уровня в наборе протоколов Интернета.

Сетевое программирование для начинающих: введение в сокеты — теоретический взгляд на один из самых популярных инструментов программирования для обмена данными по компьютерным сетям.


Добро пожаловать в 7-й выпуск сериала Networking 101 ! В предыдущей главе я потратил некоторое время на изучение концепции сокетов и интерфейса сокетов Беркли . На этот раз я хочу изучить практическую сторону сетевого программирования, отправив HTTP-запрос через Python и его ```socket``` модуль .

### Сокеты: краткое освежение ###

*Сокет* — это программный объект, который позволяет программам обмениваться данными. Наиболее популярным API сокетов является интерфейс сокетов Berkeley, обычно реализуемый операционными системами на низкоуровневых языках, таких как C. Я буду использовать Python для этого эксперимента, так как его socketмодуль очень близко соответствует исходной реализации C, без сложностей, связанных с памятью. диктуется языком C.

*Протокол передачи гипертекста (HTTP)* — это протокол для получения ресурсов, таких как HTML-документы, и он является основой всемирной паутины , какой мы ее знаем сегодня. Смысл этого эксперимента в том, чтобы использовать сокеты для отправки HTTP-запроса на внешний веб-сервер и чтения его ответа: другими словами, я напишу ультра-примитивный веб-браузер.

Я еще не касался HTTP в этой серии, но не волнуйтесь: это просто вопрос отправки и получения текстовых строк. Однако я предполагаю, что вы знаете, как работает Python, и немного знакомы со стеком протоколов TCP/IP . Давайте начнем!

### HTTP-запрос Python: первые попытки ###
Как объяснялось в предыдущей главе, сначала необходимо создать и настроить сокет. Затем вы подключаете его к хосту и начинаете отправлять/принимать данные. Наконец, вы закрываете сокет, когда закончите с ним.

1. #### Настройка сокета ####
Первым делом импортируйте ```socket``` модуль:

    
    import socket
    

Теперь пришло время создать новый объект сокета через ```socket()``` конструктор . Он ожидает два параметра: семейство сокетов и тип сокета , выбранные из набора констант, начинающихся с AF_префикса для семейства и ```SOCK_префикса``` для типа. Полный список доступен здесь .

Какие константы выбрать? HTTP основан на протоколе управления передачей (TCP) , который, в свою очередь, основан на интернет-протоколе (IP) . Это означает, что HTTP ориентирован на поток (из-за TCP) и требует, чтобы IP-адрес работал (из-за IP). Эти требования выполняются путем выбора:

константа ```AF_INET``` для семейства сокетов. Это расшифровывается как Интернет- протокол с адресами IPv4 ;

для ```SOCK_STREAM``` типа сокета. Нам нужен потоковый протокол из-за TCP.

Эти константы передаются socket() конструктору:

    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    

Теперь у нас есть рабочий объект сокета sock, настроенный для передачи HTTP. Этот тип сокета также известен как потоковый сокет .

2. #### Подключение сокета к серверу ####
Следующим шагом является выбор веб-адреса для подключения. Я буду использовать www.example.com, но вы можете выбрать что угодно — только не злоупотребляйте!

В 5-м выпуске этой серии я упомянул, как TCP использует специальные номера, называемые портами , для определения типа службы, которую вы хотите получить от сервера. Веб-серверы обычно предоставляют службы HTTP через порт 80, поэтому я выберу и его.

Затем веб-адрес и номер порта передаются connect()методу в виде кортежа:

    
    sock.connect(("www.example.com", 80))
    

В этот момент наш сокет установил соединение с веб-сервером, который отвечает за обслуживание веб-страниц ```www.example.com```через порт ```80```. Где же все-таки IP-адрес? Метод ```connect()``` автоматически переводит строку ```www.example.com``` в соответствующий IP-адрес, выполняя поиск DNS . Не беспокойтесь об этом сейчас; В будущем я напишу статью о том, как работает механизм DNS.

3. #### Отправка данных на сервер ####
А вот и веселье. HTTP-связь всегда начинается с запроса , сделанного клиентом (то есть нами!) со страницей, которую мы хотим получить, за которой следует дополнительная информация. Такой запрос отправляется в виде обычной текстовой строки и выглядит так:

    
    GET / HTTP/1.1\r\nHost:www.example.com\r\n\r\n
    

Другими словами: дайте мне ( GET) индексную страницу ( /) через HTTPверсию 1.1(HTTP поставляется в нескольких версиях, 1.1это нормально для нашей цели) с хоста с именем ```www.example.com```. Поля разделены, ```\r\n``` а запрос заканчивается ```\r\n\r\n```.

Пришло время отправить эту строку на веб-сервер, вызвав ```send()``` метод в нашем сокете. Обычно данные отправляются через Интернет в двоичной форме, то есть в виде набора 0s и 1s, упакованных вместе: вот почему ```send()``` методу нужны байты на входе. Итак, наша текстовая строка должна быть сначала преобразована в двоичную. В Python это делается путем добавления ```b''``` нему a:
    
    b"GET / HTTP/1.1\r\nHost:www.example.com\r\n\r\n"
    

Теперь строка превратилась в последовательность байтов , готовую к передаче:
    
    
    sock.send(b"GET / HTTP/1.1\r\nHost:www.example.com\r\n\r\n")
    

4. #### Получение данных с сервера ####
В этот момент сервер должен был получить наш запрос и быть готовым ответить некоторыми данными, то есть страницей, которую мы запросили. Данные получаются вызовом recv()метода:

    
    response = sock.recv(4096)
    

Метод ```recv()``` требует, чтобы максимальное количество данных было получено за один раз в байтах: 4096 должно быть достаточно на данный момент. Метод возвращает данные в виде строки байтов в том же формате, который мы использовали для запроса. Таким образом, мы можем либо распечатать его как есть, либо преобразовать во что-то значимое, расшифровав его с помощью ```decode()``` метода:

    
    print(response)             # raw byte string
    print(response.decode())    # UTF-8-encoded string
    

В любом случае мы должны получить текстовую строку, состоящую из заголовков ответа , за которыми следует тело ответа . Первые представляют собой дополнительные метаданные, а вторые — фактический HTML-код запрошенной вами веб-страницы.

5. #### Закрытие сокета ####
После получения всего ответа ```close()``` сокет:

    
    sock.close()
    

Сокет всегда должен быть закрыт правильно, как только вы закончите с ним. А теперь код, который мы создали до сих пор:

    
    import socket
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(("www.example.com", 80))
    sock.send(b"GET / HTTP/1.1\r\nHost:www.example.com\r\n\r\n")
    response = sock.recv(4096)
    sock.close()
    print(response.decode())
    

Это хорошее начало, но мы можем добиться большего: посмотрим, как.


### Понимание сетевых буферов ###
В приведенной выше программе могут произойти две ошибки: 1) запрос может быть отправлен не полностью, 2) ответ может быть получен не полностью. Давайте введем понятие сетевых буферов , чтобы понять почему.

Когда вы перемещаете данные через сокет, данные не передаются сразу через сетевую карту по одному байту за раз. Вместо этого операционная система временно помещает его в буфер — участок памяти, используемый для хранения данных, пока они перемещаются из одного места в другое.

Поэтому, когда вы ```send()``` что-то делаете, операционная система копирует часть вашего сообщения в буфер, а затем сбрасывает его во внешний мир, когда он заполняется. Прием данных работает аналогично, только наоборот. По мере того, как байты, отправленные сервером, поступают на вашу сетевую карту, операционная система собирает их в другой сетевой буфер, ожидая прибытия к ```recv()``` нему вашего приложения.

Вы не можете контролировать эти буферы: они могут быть пустыми, частично заполненными, полностью заполненными дополнительными данными для отправки/получения и т. д. по нескольким причинам — медленная сеть, загруженная операционная система, серверы не работают и т. д. Единственное, что вы можете сделать, это продолжать ```send()``` читать и ```recv()``` изучать до тех пор, пока не появятся доступные данные , если вы хотите быть на 100% уверены, что ничего не упустили.

### Лучше отправить ###
Метод ```send()``` возвращает количество фактически отправленных байтов: поскольку мы знаем длину сообщения, которое хотим отправить, давайте отследим общее количество байтов, отправленных при каждом ```send()``` вызове, сравним это значение с длиной сообщения и, в конце концов, отправим то, что осталось. Что-то вроде этого:

    
    request = b"GET / HTTP/1.1\r\nHost:www.example.com\r\n\r\n"
    sent    = 0
    while sent < len(request):
        sent = sent + sock.send(request[sent:])    # Send a portion of 'request', starting from 'sent' byte
    

Кроме того, в Python есть ```sendall()``` метод, который ведет себя точно так же, как приведенный выше фрагмент кода: используйте его, если не хотите, чтобы вас беспокоили внутренности.

#### PS: ####
- ```socket.send()``` — это низкоуровневый метод и в основном просто метод ```C/syscall send(3) / send(2)``` . Он может отправить меньше байтов, чем вы запросили, но возвращает количество отправленных байтов.

- ```socket.sendall()``` — это высокоуровневый метод только для Python, который отправляет весь буфер, который вы передаете, или выдает исключение. Он делает это, вызывая до тех пор, ```socket.send()``` пока все не будет отправлено или не произойдет ошибка.

Если вы используете TCP с блокирующими сокетами и не хотите, чтобы вас беспокоили внутренние проблемы (это относится к большинству простых сетевых приложений), используйте ```sendall```.

### Лучше получить ###
В исходном коде есть дополнительная проблема: 4096 байт может быть недостаточно для хранения полного ответа. Мы можем исправить это и проблему с буферизацией, зациклившись, ```recv()``` как мы делали выше с ```send()```. Однако здесь все сложнее, потому что мы заранее не знаем точно, какой длины будет входящее сообщение. Это связано с потоковой природой TCP, где данные рассматриваются как неограниченный поток байтов без разделителей или других границ сообщения.

Однако не все надежды потеряны. Метод ```recv()``` возвращает количество полученных байтов, а 0 байт возвращается, когда сервер разорвал соединение. Таким образом, мы можем выполнять цикл ```recv()``` до тех пор, пока не получим взамен 0 байтов. Что-то вроде этого:

    
    # [...]
    response = b""
    while True:
        chunk = sock.recv(4096)
        if len(chunk) == 0:     # No more data received, quitting
            break
        response = response + chunk;
    # [...]
    

Теперь код должен быть готов обрабатывать сообщения любой длины или, по крайней мере, должен быть способен получать все данные, отправленные сервером. Однако, если вы попытаетесь запустить его, вы заметите, что программа зависает до того, как напечатает окончательный ответ. Почему?

#### PS: ####
    Это зависит от протокола. Некоторые протоколы, такие как UDP, отправляют сообщения, и на каждый файл recv. Предполагая, что вы говорите конкретно о TCP, есть несколько факторов. TCP ориентирован на поток, и из-за таких вещей, как объем текущих ожидающих отправки/получения данных, потерянные/переупорядоченные пакеты в сети, отложенное подтверждение данных и алгоритм Nagle (который задерживает некоторые небольшие отправки на несколько сотен миллисекунд), его поведение может незначительно меняться по ходу диалога между клиентом и сервером.
    
    Все, что получатель знает, это то, что он получает поток байтов. Он мог получить что угодно от 1 до полностью запрошенного размера буфера для любого recv. Не существует однозначной корреляции между вызовом отправки с одной стороны и вызовом получения с другой.

    Если вам нужно выяснить границы сообщений, это зависит от протоколов более высокого уровня. Возьмем, к примеру, HTTP. Он начинается с заголовка с разделителями \r\n, а затем содержит количество оставшихся байтов, которые клиент должен ожидать получить. Клиент знает, как читать заголовок из-за \r\n, а затем точно знает, сколько байтов идет дальше. Часть очарования протоколов RESTful заключается в том, что они основаны на HTTP, и кто-то уже понял это!

    Некоторые протоколы используют NUL для разграничения сообщений. Другие могут иметь двоичный заголовок фиксированной длины, который включает количество любых переменных данных, которые будут поступать. Мне нравится zeromq , у которого есть надежная система обмена сообщениями поверх TCP.

#### Подробнее о том, что происходит с получением... #####

Когда вы это сделаете ```recv(1024)```, есть 6 возможностей

- Нет данных о приеме. ```recv```будет ждать, пока не будут получены данные. Вы можете изменить это, установив тайм-аут.

- Есть частичные данные приема. Вы получите эту часть прямо сейчас. Остальное либо буферизовано, либо еще не отправлено, и вы просто выполняете еще одно получение, чтобы получить больше (и применяются те же правила).

- Доступно более 1024 байт. Вы получите 1024 из этих данных, а остальные буферизуются в ядре, ожидая следующего приема.

- Другая сторона отключила розетку. Вы получите 0 байт данных. 0 означает, что вы никогда не получите больше данных на этом сокете. Но если вы продолжите запрашивать данные, вы продолжите получать 0 байтов.

- Другая сторона сбросила сокет. Вы получите исключение.

- Произошла какая-то другая странная вещь, и вы получите исключение для этого.

#### Насколько большим должен быть мой буфер recv при вызове recv в библиотеке сокетов ####

Ответы на эти вопросы различаются в зависимости от того, используете ли вы потоковый сокет ```(SOCK_STREAM)``` или сокет дейтаграммы ```(SOCK_DGRAM)``` — в TCP/IP первый соответствует TCP, а второй — UDP.

#### Как узнать, насколько большим должен быть переданный буфер ```recv()```? ####

- ```SOCK_STREAM```: Это не имеет большого значения. Если ваш протокол является транзакционным/интерактивным, просто выберите размер, который может содержать самое большое отдельное сообщение/команду, которую вы разумно ожидаете (3000, вероятно, подойдет). Если ваш протокол передает объемные данные, то буферы большего размера могут быть более эффективными — хорошее эмпирическое правило примерно такое же, как размер буфера приема ядра сокета (часто что-то около 256 КБ).

- ```SOCK_DGRAM```: Используйте буфер, достаточно большой для хранения самого большого пакета, который когда-либо отправлял ваш протокол прикладного уровня. Если вы используете UDP, то, как правило, ваш протокол уровня приложения не должен отправлять пакеты размером более 1400 байт, потому что их, безусловно, необходимо фрагментировать и собирать заново.

#### Что произойдет, если recvполучит пакет больше размера буфера? ####

- ```SOCK_STREAM```: Вопрос на самом деле не имеет смысла, потому что потоковые сокеты не имеют концепции пакетов - это просто непрерывный поток байтов. Если для чтения доступно больше байтов, чем есть в вашем буфере, они будут поставлены ОС в очередь и доступны для вашего следующего вызова recv.

- ```SOCK_DGRAM```: лишние байты отбрасываются.

#### Как я могу узнать, получил ли я все сообщение? ####

- ```SOCK_STREAM```: вам нужно встроить какой-то способ определения конца сообщения в ваш протокол прикладного уровня. Обычно это либо префикс длины (каждое сообщение начинается с длины сообщения), либо разделитель конца сообщения (например, это может быть просто новая строка в текстовом протоколе). Третий, менее используемый вариант — указать фиксированный размер для каждого сообщения. Также возможны комбинации этих параметров — например, заголовок фиксированного размера, который включает значение длины.

- ```SOCK_DGRAM```: один recvвызов всегда возвращает одну дейтаграмму.

#### Есть ли способ сделать так, чтобы буфер не имел фиксированного объема пространства, чтобы я мог продолжать добавлять его, не опасаясь нехватки места? ####

Нет. Однако вы можете попытаться изменить размер буфера с помощью realloc()(если он изначально был выделен с помощью malloc()или calloc(), то есть).

### Режим соединения HTTP и блокировка сокетов ###
Первый выпуск HTTP (версия 1.0) использует один сокет для каждой передачи. Вы отправляете запрос, сервер отправляет ответ, затем закрывает соединение. Когда соединение закрыто, ваш сокет может быть уничтожен: его невозможно использовать снова. Хотите оформить новый запрос? Просто создайте новый сокет и начните заново. Со временем этот подход оказался очень ограниченным, поэтому в версии HTTP 1.1 — версии, которую мы используем! — созданы новые модели подключения. В HTTP 1.1 все соединения являются постоянными , если не указано иное: сервер поддерживает соединение, чтобы сокет можно было повторно использовать для дополнительной передачи.

К сожалению, постоянный режим немного конфликтует с сокетами, которые блокируются по умолчанию: они приостанавливают работу программы, ожидая отправки или получения данных. Или, что еще лучше, они блокируются до тех пор, пока какие-то данные — хотя бы один байт — не станут доступны в сетевых буферах. Поскольку сервер никогда не закрывает соединение в постоянном режиме, сокет просто ждет поступления дополнительных данных. Сервер больше не будет отправлять данные (если мы не отправим новый запрос), поэтому сокет зависает навсегда.

Помимо возврата к HTTP/1.0, есть три способа решить проблему: 1) отключить постоянное HTTP-соединение, 2) установить тайм- аут для сокета или 3) прочитать заголовки ответа HTTP, чтобы определить, когда нужно выйти. Давайте взглянем.

1. #### Отключите постоянное HTTP-соединение. ####
Заголовок Connectionопределяет, остается ли соединение с сервером открытым после завершения передачи. В HTTP/1.1 значение по умолчанию — keep-alive. Измените его на close в строке HTTP-запроса, чтобы имитировать поведение HTTP/1.0 по умолчанию:
    
    
    sock.send(b"GET / HTTP/1.1\r\nHost:www.example.com\r\nConnection: close\r\n\r\n")
    

Таким образом, сервер корректно закроет соединение после отправки всех данных. Сокет обнаруживает это, ```recv()``` возвращает 0, и код может выполняться.

2. #### Установите тайм-аут на сокете ####
Вы можете решить, как долго сокет должен блокироваться, прежде чем сдаться. Это делается путем вызова ```settimeout()``` объекта сокета во время настройки. Теперь все операции с сокетами ( connect(), send(), recv(), ...) вызовут ```socket.timeout``` исключение, если они занимают больше времени, чем запрошено. Вы можете поймать эту ошибку при вызове ```recv()``` цикла ```while``` и интерпретировать ее как конец данных. Например:

    
    import socket
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)  # In seconds. Choose a value that makes sense to you
    # [...]
    response = b""
    try:
        while True:
            response = response + sock.recv(4096);
    except socket.timeout as e:
        print("Time out!")
    # [...]
    

Примечание: в Python 3.10 и более поздних версиях ```socket.timeout``` это просто устаревший псевдоним для ```TimeoutError``` исключения.

3. #### Прочтите заголовки ответа HTTP, чтобы определить, когда нужно выйти. ####
Заголовок ```Content-Length``` ответа указывает размер тела сообщения в байтах, которое сервер отправляет вам обратно. Идея здесь состоит в том, чтобы продолжать проверять входящие данные на наличие этого заголовка и читать его значение, когда оно доступно. Затем вы можете остановить ```recv()``` получение данных из сокета, как только вы получите число байтов, соответствующее значению, сообщаемому ```Content-Length```.

Разбор HTTP-ответов немного раздражает, но выполним и без библиотеки. Каждый заголовок отделяется , ```\r\n``` а тело (т. е. фактический HTML-код) начинается после ```\r\n\r\n```. Очевидно, что этот подход работает только с HTTP: другие протоколы могут отправлять длину содержимого в другом формате или вообще не отправлять его.


### Заключительные заметки ###
Эта статья призвана стать практическим введением в сокеты Беркли по потоковому протоколу. Я только что поцарапал поверхность темы; Ниже приведен список интересных вещей, о которых следует помнить:

Все методы сокетов, используемые на этом пути, могут генерировать другие исключения помимо ```socket.timeout```. Я не делал этого для краткости, но вы должны поймать их и действовать соответственно;

Сокет может быть установлен в неблокирующий режим. Все операции с сокетами ( connect(), send(), recv(), ...) больше не ждут в этом режиме: они немедленно возвращаются , как только вы их вызываете. Это решает проблему зависания сокетов, однако написать правильную программу с неблокирующими функциями довольно сложно. В одной из следующих статей я попытаюсь переосмыслить увиденный до сих пор код неблокирующим образом;

Наш сокет был настроен для работы через IPv4. Вы можете переключить его на IPv6, установив семейство сокетов ```AF_INET6``` во время настройки. Однако код немного меняется, особенно его ```connect()``` часть. Этот пример в официальной документации показывает, как его адаптировать;

Мы выдали HTTP-запрос, но сейчас все используют HTTPS — безопасную, то есть зашифрованную версию HTTP. Код не сильно меняется, но вам нужно шифровать и расшифровывать данные. В этом помогает модуль Python ```ssl```, и я, возможно, напишу о нем статью в будущем.

### Сокет и буфер означают одно и то же? ###

Сокет — более широкое понятие, чем буфер. Сокет имеет два буфера и некоторую другую информацию, связанную с ним.

В контексте программирования сокетов сокет — это интерфейс вашего приложения для одного соединения TCP (или потока UDP). Ваше приложение не читает/записывает данные с/на сетевую карту (NIC) напрямую, оно проходит через сетевой стек ядра. Буферы сокетов — это короткие очереди пакетов, которые ядро ​​хранит от имени вашего приложения, поскольку оно перетасовывает данные между сетевым адаптером и пространством памяти вашего приложения.

Буфер отправки или буфер записи — это очередь пакетов, которые ваше приложение передало в сетевой стек для отправки, а буфер приема или буфер чтения — это очередь пакетов, полученных сетевым стеком ядра от имени вашего приложения, которые оно ожидает ваше приложение для чтения (то есть оно хранится в пространстве ядра, ожидая, пока ваше приложение/процесс запросит его копирование в память вашего приложения).

На стороне отправителя для лучшей производительности ваше приложение должно вызываться write()достаточно часто и с достаточным количеством данных, чтобы в буфере отправки ядра никогда не заканчивались данные для отправки. Мы называем это «держать трубу полной». Но чтобы свести к минимуму задержку, ваше приложение не должно загружать буфер отправки ядра слишком большим объемом данных.

На стороне получателя, для лучшей производительности, ваше приложение должно вызываться read()достаточно часто, чтобы поддерживать буфер приема ядра пустым. В противном случае, если в приемном буфере недостаточно свободного места, сетевой стек сообщит отправителю, что его приемный буфер заполняется, что приведет к снижению скорости отправки данных отправителем.

### Полезные ссылки: ###

[блокирующие и не блокирующие сокеты](https://www.scottklement.com/rpg/socktut/nonblocking.html)
[Руководство Beej по сетевому программированию](https://beej.us/guide/bgnet/html/)
